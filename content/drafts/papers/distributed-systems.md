## Keeping CALM: When Distributed Consistency is Easy

https://arxiv.org/pdf/1901.01930.pdf

The CALM Theorem presents a positive result that delineates thefrontier of the possible. CALM shows that monotonicity, a propertyof a program, implies consistency, a property of the output of anyexecution of that program. The inverse is also established: non-monotonic programs require runtime enforcement (coordination) toensure consistent execution. As a program property, CALM enablesreasoning via static program analysis, and limits or eliminates theuse of runtime checks. This is in contrast to storage consistency likelinearizability or serializablity, which required expensive runtimeenforcement.

CALM falls short of being aconstructiveresultâ€”it does not actu-ally tell us how to write consistent, coordination-free distributedsystems. Even armed with the CALM theorem, a system buildermust answer two key questions. First, and most difficult, is whetherthe problem they are trying to solve has a monotonic specification.Most programmers begin with pseudo-code of some implementa-tion in mind, and the theory behind CALM would appear to provideno guidance on how to extract a monotone specification from a can-didate implementation. The second question is equally important:given a monotonic specification for a problem, how can I imple-ment it in practice? Languages such as Bloom point the way to new paradigms for programming distributed systems that favor and(conservatively) test for monotonic specification. There is remain-ing work to do making these languages attractive to developers,and efficient at runtime.